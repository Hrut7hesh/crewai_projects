https://us02web.zoom.us/j/81192627926?pwd=BNmq4lwvUOOaXMC0bjj8t4BiMMQe7n.1

Java is an object oriented programming language

Desktop applications 
Web applications (enterprise applications)
Embedded applications

Java Software Editions

JSE : Java Standard Edition
JEE : Java Enterprise Edition
JME : Java Micro Edition

Version numbers is not that important in simple cases, however, versions are considered in some cases based on the situation

Installing Java.
************
JSE :   JDK =  Java Development Kit
JDK Tools, What are they ? 
These are the Java Software commands which are located in the "java x.y.z\ bin"   folder of Java installation.
e.g.    java,  javac , jar  

JDK : Java Development Kit
JRE : Java Runtime Environment
JVM : Java Virtual Machine
JDK Tools : commands  e.g.  javac,  java,  jar

JDK = JDK Tools + JRE

JRE = Java libraries  + JVM  
Java libraries are nothing but the built in java programs which are available in the form compressed files called jar files

JAR (Java Archive) : It is a compressed collection of .class files in built into Java software

JVM : Java Virtual Machine. It is the machine that is responsible for loading and executing the Java code

Who loads and executes the Java code ?
JVM 

Who is the JVM  a part of ?
JRE

First program
***********
created a file
compiled it.  To compile one or more java programs we make use of "javac"

javac Hello.java
javac First.java

javac *.java


If the compilation is successful, the compiler generates a file with an extension .class (e.g.  Hello.class)

To execute a  java program (java code), we need to make use of the command named "java"


java <the name of the .class file which contains a valid public static void main(String args[])  method>


java Hello


hello.c
void main() {
  printf("Hello from C program...");
}



gcc hello.c  
hello.exe : this file is automatically generated when we compile the C program. This file contains the code the OS understands


hello.c --- compiler ---hello.exe--- specific OS (E.G  windows) -- CPU (hardware)


Hello.java ---> javac compiler --->  Hello.class (bytecode, which is not understandable by any OS)---> JVM  --> JVM converts bytecode to native code of the target OS ---> CPU..

WINRAR


Java primitive data types
*********************
8 data types

Integer --- >    byte short  int  long
Decimal ---     float  double

true/false ---   boolean

character --    char



class Hello {
  public static void main(String args[])  {
     int x = 10;
     byte b1= 20;
}

}


All literals with decimals belong to  "double" data type in java by default. therefore, if we want use float data type we need to provide a suffix  f or F

All integer literals belong to  "int" data type in Java. therefore, we need to do appropriate type casting wherever applicable



The structure of a Java program

A java program is a collection classes or interfaces or enums


A class is a collection of variables and methods (methods in java are nothing but functions in C language)

A more advanced usage of a class can include   variables, methods, constants, nested classes, nested interfaces, nested enums  etc


employeedetails
emloyeedepartmentinformation
bankacountinformation
savingsbankaccount
currentaccount
loanaccount


departmentnumber
employeedepartnmentname
accountbalance
showbalance()
getbalance()
showempdetails()
getaccountbranchname()



We generally need more than one class, how ever it is not compulsory to have more than one class

An object is a special variable, whose data type is the name of a class.

It is a special variable,   because it is made up of variables, methods and other things declared in a class. 
*****NOTE.  An object contains only non static members****


Calculator c1, c2, c3; 
c1 = new Calculator(); //  x, y, sum, prod
c2 = new Calculator();  //  x, y, sum, prod
c3 = new Calculator();   // x, y,, sum, prod

Members of an object
*****************
When we create an object, it contains all those non static variables, methods, etc declared in that class. these are called as members of object

In order to make use of the variables of the object, we use the following
objectname.variablename = value;
c1.x=10;
c2.x=30;
c3.x=45;

In order to execute the methods on an object, we use the following syntax

int result =  c1.sum();
c1.prod();


Declaring and creating an object in a single statement; in the same statement

classname object-name = new classname(); 

e.g.

Calculator c1 = new Calculator();

=========================================================================================
8th April 2025

Create a BankAccount class as follows
1.  actNumber, customerName, actBalance
2.  withdraw(double howMuch), deposit(double howMuch) void
The withdraw() method should the available balance (actBalance) before withdrawing, and should not withdraw if balance is low, otherwise withdraw can happen.

3. after withdrawing or depositing, a message should printed, with balance before and after transcation


Create a BankAccountMain1 class, with a main() method, and in the main() method, create the object of BankAccount class, and peform the withdraw/deposit operations

1.JDK vs JRE vs  JVM
2. What is JVM, its internal parts like  class loaders, memory partitions,  how does JVM work
3. Garbage collection


	
Nullifying an object
*****************
It means , assigning null to an object reference
E.g.  
 Employee e = new Employee();
    e.setEmpNumber(1234);
    e.setEmpName("Scott");
  e  = null;  // this is nullification of e
  e.setEmpNumber(1234) ; // this statement causes NullPointerException, because e has no more access to the object

Garbage collection
***************
It is the process during which, the "garbage collector" reclaims (releases) the memory of unreachable/nullified objects.


Java program compilation and execution process.
*****************************************
Dev Types the code (e.g. Hello.java)  ===>  compiler, javac Hello.java ===> Hello.class (bytecode) ===>  run the code using "java Hello"==> one instance of JVM is loaded into memory===> a series of things happen ===>  JVM makes a call to the main() method (using the Hello.main() )===> main() method makes calls to subsequent code


All integer literals in java are considered to be of "int" data type by default

All floating literals in java are considered to be of "double" data type by default

to print non English, alphabet

class  PrintNonEnglish {
   public static void main(String args[]) {
   // write your code here....
  }
}

class   MyBank {
    static double balanceInBranch;
    double customerBal1;
    double customerBal2;
   
   static void showBranchBalance() {
    System.out.println("Branch balance = " + balanceInBranch);
   }
   void showCustomer1Balance() {
   System.out.println("Customer 1 balance = " + customerBal1);

   }

}

classname.staticmembername = value;
classname.staticmethodname() ;

MyBank.balanceInBranch = 10000.00;
MyBank.showBranchBalance();


class   Test {
 // we can declare variables
// we can declare methods

 // we can declare constants
 // we can declare enums
 // we can declare a class
 // we can declare an interface

}

class Test {


   static class Customer {

   }
   class Employee {

    }
}


Types of variables
****************
Local variables
Instance variables
class variables / static variables

Local variables are stored on stack, they don't have any default value, don't occupy space unless we assign an initial value.

Instance variables are stored on HEAP,  they are loaded into memory when an object is created, after they are loaded into memory, the hold some default value.  which default they hold depends on their data type as follows

byte  short int long   =    0       float double  = 0.0    boolean = false  char=\u0000 (null character)
any class type = null

class Demo  {
   static int x;
   static int y;
  public static void main(String args[]) {
  
 }

}
 
 javac Demo.java == compiled...   Demo.class (bytecode)

"java Demo"

1. JVM is loaded into memory
2. JVM does a series of things.
3. JVM loads the Demo.class into memory
4. After the .class file is loaded into memory all static variables, static methods, any thing static is loaded into memory.
    the static variables are loaded on the method area, and hold the default values according their data type in the 
 similar fashion, like the instance variables



static vs non static
*****************
static members : If any variable or method or any thing static, is there, there will be only one copy that member in existence in memory

non static members :  If any variable, method, or anything non static, they will exists in memory one copy per object

class Demo {
   static int x;
   static void hello() {

  }
    int j=10;
  public static void main(String args[]) {
   Demo d1 = new Demo();
  Demo d2 = new Demo();
  } 
}

static block  and non static block
**************************
block means: any code surrounded with {  }  without any method name, block name, nothing

class Demo {

  {
      System.out.println("hello world... from non static block");
   }
  static {
   System.out.println("hello world... from STATIC block");

 }

}

We cannot use non static code inside static code (without any object creation)

static block code gets executed once per the class. This block is executed as soon as the class is loaded into memory


Anything which is non static is related to object, and appears in memory on per object basis


Anything which is static, is related to class, and appears in memory on per class basis


Method overloading
******************
It is the process of defining the same method more than once.
"Method overloading is used to achieve static polymorphism"
e.g.

 class Shape {
   public void area(int length, int breadth) {
   // code to print the area of rectangle
   }

    public void area(double base, double height) {
  // code to print the area of triangle
  }

  public void area(int side) {
  // code to print the area of square
  }

}


What will happen if we try to compile and run the following code?
 NOTE:   length() is a method in String class. String is a built in class. 
class Test {
  public static void main(String args[]) {
    String s1 = null;
     System.out.println(s1.length()); 
  
 }

}


We cannot use non static code inside static code (without any object creation)

class Test {
  int x=10;  
 public static void main(String args[]) {
   System.out.println(x); // this will be an error
 }
  
}

local variable  OR instance variable OR static (class variable)

1. save
2. javac Test.java
3. java Test ==> JVM is loaded into memory===> JVM does a series of things==>JVM loads Test.class  file ==>JVM loads all static blocks, static variabes,static methods etc ==> JVM calls the main()



The "final" keyword
*****************
It has 3 different uses.
1.  to declare constants
2. to prevent method overriding 
3. to prevent inheritance . (to prevent a class from being extended)

What is a constant?
A constant is data member whose value CANNOT be modified/changed after we assign a value to it for the first time

the "this" pointer
**************
JVM internally maintains one built in pointer named  "this" 
"this" always points to the currently active object.
currently active object means, the object upon which the code like method is in execution, variable in execution

Arrays in Java
************
What is an array ?
  An array is a group of variables that have a common name and same data type 
  each variable in the array is called element.
NOTE. Arrays in java are considered as objects.  that means, we need to create arrays by the use of new operator
 creating array means, allocating space to individual array elements in memory

  datatype  arrayname[] ;
 int scores[] ;

 Array creation syntax;
*******************
arrayname = datatype[how many elements we want];

scores = new int[4];


Array declaration and creation on the same statement
*******************************************
datatype arrayname[] = new datatype[size];
int marks[] = new int[5];
String names[] = new String[3];


Array initialization
***************
Initialization means, providing/defining the initial values to the elements of the array during array creation

datatype arrayname[] = new datatype[] {val1, val2, val3.....valN} ;
datatype arrayname[] =  {val1, val2, val3.....valN} ;

int scores[] = { 23,34,45,56,67} ;
String names[] = {"Java", "SpringBoot", "React JS", "Angular" };

WAP to demonstrate 2D array of int
3 3


Array of objects
*************
class BankAccount {
  int actBalance;
  String customerName;
 
}

I want to create and initialize an array of BankAccount objects of element size 3 ;

I want an array of 3 elements, each element of the array should be an object of BankAccount class

Write down the statement or statements (as applicable) to create, initialize the array for afore mentioned statement


The ArrayIndexOutOfBoundsException
*******************************
This exception occurs, if we refer to an array index beyond the array size
int marks[] = {34,456,6};
marks[4] = 120; // this compiles well, but it causes an exception during runtime
final keyword and object references


The command line arguments
************************

arguments
********


void function1() {
function2(10,20);
}


void function2(int i, int j) {


}

9th April 2025
==================================================================================
Constructors
**********
1. A constructor is a special method of a class whose name is same as it's class name and which has no return type

e.g.
  class Demo {
   
   void greet() {

   }

   Demo() {

   }

  }


2. Constructor execution (When is a constructor executed? ) 
   It is executed on every object , during object creation time.   

3. How many times a constructor will be executed ? 
  only once. during the object creation time.  

4. Can we execute a constructor manually  ? (i.e. can we invoke the constructor manually) 
  NO.  (this question has a YES NO answer depending the topic of this() constructor usage)

5. What is the use of a constructor?   
 It is used to provide custom initial values to the instance variables of the object

6. Constructors can be overloaded. i.e. we can declare more than one version of the constructor, as long as we following overloading rules (i.e.. in case of overloading we must ensure that either the number of parameters to different versions of the constructor or different, or if they are same, then we have to ensure that their data type sequence is different )

7. Default constructor :  A constructor that has NO PARAMETERS (zero parameters) is  called default constructor.    
 NOTE.  While creating a java file, if we don't type at least one constructor version , then the compiler will automatically add a default constructor into the class.

  In other words, what we type is the below one
    class Test {
            
   }
 what it becomes is the below one
    class Test {
      Test() {

   }
}


8. Constructors can be declared  public OR private OR protected OR nothing (nothing means default)

9 . Constructor cannot be static,  constructor cannot final


10. super() constructor. this topic is related to inheritance.



instance variables and static variables have a default value.  what is the default value depends on the data type
byte short int long 0   ,  float double 0.0   char  \u0000   boolean false  for any reference null

this()  constructor.  It is used to call/invoke  one version of a constructor from other version of the constructor within the same class

class Demo {
  Demo() {
      this(10) ; // this line executes Demo(int x) { } version of constructor
      System.out.println("Demo() default constructor...");
 }
  Demo(int x) {
     
    System.out.println("Demo(int x) constructor...");
  }
  public static void main(String args[]) {
   new Demo();
   System.out.println("After object creation...");
  
 }
}


What is encapsulation and why do we need it ?
encapsulation means binding  variables and methods into single unit/class.

Problem, if we don't use/apply encapsulation.
************************************
If we make changes to the variable names then , it breaks all the code where those variable names are already used.

How to achieve encapsulation ?
   Declare the variables private, and for each variable provide a pair of public methods called set/get 
Uses
*****
maintainability, security.

private/public

class Employee {
  private int empNumber;
  
}

 public class EmployeeMain1 {
   public static void main(String args[]) { 
    Employee e1 = new Employee();
     e1.empNumber = 101;
     
   }
 }
 public class EmployeeMain2 {
   public static void main(String args[]) { 
    Employee e2 = new Employee();
     e2.empNumber = 101;
     
   }
 } public class EmployeeMain3 {
   public static void main(String args[]) { 
    Employee e3 = new Employee();
     e3.empNumber = 101;
     
   }
 }



Wrapper Classes
*************
What are wrapper classes ? 
  These are the classes which WRAP primitive data type variables into objects of respective types
  All these classes are available and declared in the package called  "java.lang"

  int   Integer     byte  Byte    short Short   long  Long   float Float  double Double   boolean Boolean  char Character

 public class Integer {
 
   public static int valueOf(int i) {
     return ......
   }
 
}


What is the use of a wrapper class ?
  We use wrapper classes in java collections.  because collections does not allow primitive data types in them
WRT:  equals() parseInt()  valueOf()  compareTo()


Inheritance
**********
What is inheritance ?
It is an approach in OOP in which one class acquires the properties, methods etc of some other class

Inheritance concepts
*****************
superclass:   It is a class whose properties, methods etc are acquired (inherited) by other class.

subclass: It is a class which acquires the properties, methods etc of super class.

the "extends"  keyword.  It is used to declare a subclass, which wants to inherit from a super class

class classname extends <superclassname>  {

}

When a subclass is created, it copies/inherits/acquires,  the properties, methods etc from it's super class.

NOTE: which all properties, which all methods, which all other features that a subclass acquires from super class depends on the visibility or access specifiers that we use to declare

Java (JDK) has so many built in classes.  e.g.  String, StringBuffer, Integer, System, Math,  Object

the Object class in java is one among many built in classes.

the Object is the super class of all java classes.

class One  {
  int x;
   void goodafternoon() {
     System.out.println("Hello, welcome and good afternoon");
  }
}


class Two extends One {
  // this class Two contains the features from class One as well as class Object


}

class InheritMain1 {
    public static void main(String args[]) {
   Two  t1 = new Two();
     t1.x=100;
     t1.goodafternoon();
  }
}

Types of inheritance
*********************
single inheritance :  one super class and one sub class  A->B
multi level inheritance-- A-->B--C--D
hybrid inheritance A-B  A-C
multiple inheritance  A, B --->C

Java does not support multiple inheritance by classes, however, it supports using interfaces


Benefits of Inheritance
*******************
1.  Code reusability
2. To achieve polymorphism

Common things go in parent class / super class and those parts of the code  which is applicable ONLY to PermanentEmployee will be declared in that class, and those parts of the code which is applicable ONLY to ContractEmployee will be declared in that class.

Employee
********
empnumber, empname,  attendance getters/setters


public class Employee {
private int empNumber;
private String empName;
private int attendance;  // how many days in a month the employee worked.

public Employee() {

}

public Employee(int empNumber, String empName, int attendance) {
	this.empNumber = empNumber;
	this.empName = empName;
	this.attendance = attendance;
}

public int getEmpNumber() {
	return empNumber;
}

public void setEmpNumber(int empNumber) {
	this.empNumber = empNumber;
}

public String getEmpName() {
	return empName;
}

public void setEmpName(String empName) {
	this.empName = empName;
}

public int getAttendance() {
	return attendance;
}

public void setAttendance(int attendance) {
	this.attendance = attendance;
}


}





PermanentEmployee
    This employee is permanent:    
ContractEmployee
    This is temporary  : 







Acquiring properties and methods from parent class to child class.
Inheritance helps in 
(i) code reusability
(ii) polymorphism

We use "extends" to implement inheritance

We have different types of inheritance.   single level, multi level, multiple, hybrid


Multiple inheritance is not supported in Java by using classes, but supported by using interfaces.


Method Overriding
****************
Method overriding is an approach in which a child class redeclares a method of it's parent class with same syntax.  same syntax means - same method name, same parameters, same return type

The object reference of a super class, can point to an  object of its subclass

When an object reference of a super class, points to an object of it's subclass, then  that pointer will not have access to those variables, methods, etc which are declared exclusively in the subclass.  However, that pointer can have access to those methods which are inherited, which are overridden 


Animal a ;   // line 1
Dog d = new Dog();  // line 2 
a = d;   // line 3
 a.walk();   // works , because walk() is inherited  // line 4
 a.sound(); // line 5 works, because sound() is overridden.  sound() version of Dog class is executed
 a.bite(); // line 6 fails, doesn't work, because this is exclusive to the Dog class
Cat c = new Cat(); // line 7
a = c;  // line 8 
 a.walk();   // line 9 works , because walk() is inherited
 a.sound(); //line 10 works, because sound() is overridden.  sound() version of Cat class is executed


An abstract method is that one which has ONLY declaration. It has no implementation

An abstract class is that one which has AT LEAST one abstract method.
In other words, if a class contains AT LEAST one abstract method then that class has to be declared as an abstract class




abstract public class Animal {

	 abstract public void sound() ;
         public void walk(){   }
}
public class Dog extends Animal {

	public void sound() {
		System.out.println("Dog barks  bow...");
	}

     public void bite() {  }
}





public class Cat extends Animal {

	public void sound() {
		System.out.println("Cat sounds meow...");
	}
	
}

public class AnimalService {
public static void someMethod(Animal a) {
            a.sound();
 }

}
public class InheritMain2 {
public static void main(String[] args) {
	Dog d = new Dog();
        Cat c = new Cat();
 
          AnimalService.someMethod(d);  // will this work 
        AnimalService.someMethod(c); // does this also work
}
 

}


What is the use of method overriding ?
To achieve runtime polymorphism.   code reusablity. 
Customized behavior

class MainClass {
    public static void main(String args[]) {
     Animal myAnimal ;
     Dog d = new Dog();
     d.displayInfo();
     
 }

}


Object typecasting.
****************
long x = 10L;
int y = (int)x;  // what is the correction here

Animal a;
Dog d = new Dog();
Dog temp;
a = d;
temp = (Dog)a; 
temp.bite(); // will this work

Abstract class should be used in a situation where there needs a parent class which provides common functionality to all child classes, and asks all the child classes to provide special functionality to themselves in their own code.


10th April 2025
==================================================================================

Abstract method.
===========
An abstract method is that one which has no implementation. It just has a declaration.
We should use "abstract" keyword to declare an abstract method
e.g.
     abstract void greet();

Abstract class
=========
#1 A class which contains at least one abstract method is called abstract class, and we should declare the class using "abstract" keyword

#2. We cannot instantiate an abstract class (i.e. We cannot create an object of an abstract class)

Welcome w  = new Welcome();  // we cannot do this, since Welcome is an abstract class

abstract public class Welcome {
  public abstract void greet(String msg);
  public abstract void newYear(int year);
  
  // abstract class can contain both abstract methods, non abstract methods (concrete methods)
  
  public void showFullName(String fname, String lname) {
	  System.out.println("Hello ==> " + fname+" "+lname);
  }
}
#3. Concrete methods: it is another name for non abstract methods

#4. Concrete class:  It is another name for non abstract class

#5. If we cannot create an object of an abstract class, then how can we make use of the concrete method(s) of the abstract class?
     We need to create a subclass of the abstract class. 
    The subclass of an abstract class 
    (i) has to EITHER override all abstract methods concretely
    (ii) OR if it overrides few or 1 abstract method concretely then the subclass has to be redeclared as abstract class

abstract public class Welcome {
  public abstract void greet(String msg);
  public abstract void newYear(int year);
  
  // abstract class can contain both abstract methods, non abstract methods (concrete methods)
  
  public void showFullName(String fname, String lname) {
	  System.out.println("Hello ==> " + fname+" "+lname);
  }
}

abstract class WelcomeChild1  extends Welcome {
  public void greet(String msg) {

   }
  public abstract void newYear(int year);

public void showFullName(String fname, String lname) {
	  System.out.println("Hello ==> " + fname+" "+lname);
  }

}


abstract class Demo  extends Object{
  abstract void m1();
  abstract int m2(); 
  abstract int m3(int x, int y); 
  void   m4() {
    System.out.println("I am non abstract 1 in Demo class");
   }
  void   m5() {
    System.out.println("I am one more non abstract method  in Demo class");
   }

}


abstract class X extends Demo {
 void m1() {  }


}

abstract class Y extends X {
int m2() {  return 0; } 
}

class Z extends Y {
   int m3(int x, int y) { return x+y ; }
}


#6  Abstract can be a child of other class  (the other class can be non abstract or concrete)

#7. abstract class can have constructors

abstract  class Demo  {
    Demo() {

   }
    abstract void m1(); 
   void m2() {  some code here }
}


#8.  There can be an abstract class with ZERO abstract methods in it (but in reverse, if we declare at least one abstract method, then we have to declare the class as abstract)
 abstract class Demo {
     void m1() { // some code here  }
   void m2() { // some code here  }
   void m3() { // some code here }
 }


#9. An abstract class CANNOT be declared as "final" (In other words, we cannot use  final and abstract together)

final abstract class Demo {   // this class declaration is wrong and results in compilation failure
    
 }

#10. An abstract method CANNOT be final  In other words, we cannot use  final and abstract together)

final abstract class Demo {   // this class declaration is wrong and results in compilation failure
      final abstract void m1(); // this is incorrect
 }




WelcomeChild extends Welcome (with a main method in it)

Inside the main() method you should create an object of the child class and execute the greet() and showFullName() methods


Preventing method overriding 
===================
If we don't want a method to be overridden then we have to declare it using the "final" keyword

e.g.
 class Demo {
    final void m1() { // some code here }
    final void m2() { // some code here }
    final void m3() { // some code here }
    final void m4() { // some code here }

  }

class DemoChild extends Demo {
   void m1()   {   }   // this is an error,, we cannot override the final methods
}


Preventing Inheritance
===============

If we want a class not be extended (inherited) then we have to declare the class as "final"

e.g.
  final class Demo {

}

 class DemoChild extends Demo {  // this is an error, we cannot extend  a final class

}

The super keyword
=============
It is used to refer to the variables/methods/etc of an immediate super class from within the code of subclass in case the child class declares the variables, methods etc with same name

The super() constructor
================
It is used invoke the constructor of an immediate super class from within the constructor of a subclass

NOTE. When an object of any class is created, then constructors of all it's super classes are executed from top to bottom in descending  order of inheritance (this is achieved using super() constructor)

class A {
  A() {
     super();  // this line makes a call to Object();
  }
}

class B extends A {
   B() {
      super() ;  //  this line makes a  call to the A()
 }

}

class C extends B {
   C() {   
     super(); // this line makes a call to B();
   }
}

class Main  {
   public static void main(String args[] ) {
   new C();  
}

}

NOTE: A call to super() constructor will be automatically there, even if we don't type it.

NOTE. the call to super() must be the first statement in any constructor. If it is not first, it will be a compilation failure

**** On an object, the constructor is the first code to be executed, all other code such as methods, are any thing else need to be executed after the constructor execution,  because,  the instance variables, the instance methods, of an object will be loaded into memory ONLY after the constructor is completed***
class A {
   String name;
  A() {
     showName(name) ;
     super();
 }
 void   showName() {

 }
  public static void main(String args[])  {
   new A();
   }
}


*****super() can optionally take parameters****



Interfaces in Java
*************
NOTE.  The answer to the question, "what is an interface?"  depends on version specific

Up to and including version 7 of java, an interface is a collection of abstract methods and/or constants.

From version 8 of Java, an interface can contain special methods called "static methods"  , "default  methods"

"Java version 8 features"

The  "interface" keyword
=================
We use "interface" keyword to declare an interface
NOTE. All constants declared in an interface are automatically public, static, final
All the methods declared in an interface are public and abstract
e.g.
 interface Demo {
  int MAX_VALUE = 10;  
int MIN_VALUE = 1;
  public abstract void greet();
  void calculate();
  }

 "What is the use of interfaces ?  OR Why should we use interfaces ?"

We cannot create an object of an interface . (we can declare object reference to an interface)


public interface Greet {
	 public abstract void wish(String name);

	 
}
//  Name of the interface + Impl  e.g.     "GreetImpl"
//  name of logic implementation  + interface name   BirthdayGreet ,  NewyearGreet

public class BirthdayGreet   implements  Greet{
 public  void wish(String name) {
      System.out.println( "Hello, "  +  name + " Wish you a happy birthday ");
  }
}
Greet g = new Greet() ; // this is incorrect

Greet  g ; // this is OK

If the interface contains ONLY abstract methods and if we cannot create object for an interface, then how can we use the method(s) of the interface.

In order to work with interface (in order to make use of methods declared in an interface), we need to declare a class, that overrides all methods of the interface.

A class that implements an interface, has to either override all the methods of the interface, OR ELSE, if it overrides 0 or 1 or few methods of the interface then it has be declared as abstract

 After we create a class that implements an interface, then we need to create an object that class and the execute methods on that object.



"Object reference of an interface, can point to an object of it's implementing class"
    Greet g1 = new BirthdayGreet();
    g1.wish("Scott");  // this works
    g1.inviteFriends() ; // this wont work.


two more classes that implement the Greet interface, and then make g point to different objects at different times and the call the wish() method accordingly 

We can define any number of implementing classes for an interface

1. Declare an interface called 
  
Circle
====
     void drawCircle();

2. Declare 3 classes,   SolidCircle,  HollowCircle,  SemiSolidCircle   each class implement the Circle interface
 Inside the drawCircle() method of each class,  you should print "Solid circle implementation" etc.

3.  Create a main class,  CircleIntfMain1 ,  and inside the main method, create  Circle c = ...  just like in the Greet example

  

Checkout
********
processPayment(double checkoutAmount);

DebitCardCheckout 
     double  availableBalance=10000;
 processPayment(double checkoutAmount) {
 System.out.println("checkout processed using debit card..")
 }
CreditCardCheckout
        double  availableBalance=10000;

NetBankingCheckout
        double  availableBalance=10000;


CheckoutIntfMain1


A few more points about an interface

1.  We cannot create object of an interface
2.  We can declare an object reference to an interface which can point to its implementation class
3.  We can define any number of classes that implement the same interface
4.  One interface can extend other interface  just like one class extends other class
public interface Shape {
	  public abstract void simpleShape();
}

   public interface ExtendedShape extends Shape {
 public abstract void advanchedShape();
}

public class ShapeImpl  implements ExtendedShape {

}

5. Java supports multiple inheritance using interfaces
    e.g. 
   interface One  {
   void m1();
   }
   interface Two {
    void m2();
   }
    interface Three extends  One, Two {
    void m3(); 

    }
     class  ThreeImpl implements Three {
             public void m1(){   }     public void m2() {   }   public void m3() {    }
        public static void main(String args[]) {
        Three a1 = new ThreeImpl();
               a1.m1();   a1.m2();   a1.m3();
       }
     }

6. A class at given time can extend other class and also implement zero or many  interfaces
    
   class  Demo {    }
   interface One  {
   void m1();
   }
   interface Two {
    void m2();
   }
  class Test extends Demo implements One, Two {

   }

 "What is the use of interfaces ?  OR Why should we use interfaces ?"

11th April 2025
==================================================================================
Packages 
********

A package is folder in which the related classes, interfaces , enums etc are placed

packages are used organize all related classes interfaces enums etc into one unit

Java software comes with a lot of built in packages
A few package names are 
java.lang
java.util
java.sql
java.io

To create a package we make use of the "package" keyword and package statement.

A.java
package p1;
class A {

}


B.java
package p1;
class B {

}


C.java
package p1;
class C {

}

Steps to work with packages
************************
1. create packages as needed and then start creating java files such as class, interface

importing members (classes, interfaces etc)  of package into other package

package naming standards.

Generally packages are named after the domain name in reversal

It is a best practice to type the package names in lower case.  if the package name contains  more than one word they are separated with a .


access specifiers
*************
Access specifiers are those keywords, which are used to declare the scope OR visibility of a class, an interface, the member of a class or interface

public  private  protected  ----  (default)

class A {
    int x;

     void m1() {

     }
}


public members are visible across all java files of all packages
private members are visible only in the class in which they are declared.
protected members are visible 
 (i) within the same package  any subclass, any non subclass
 (ii) any subclass outside the package
default members are visible anywhere with in the same package

Exception handling
****************
An exception is a runtime problem ( a problem that occurs during runtime, i.e. during program execution time)

class Test {
  public static void main(String args[])  {
System.out.println("hello  world");
int i=10/0;
System.out.println("Good morning...");
}
}

Exceptions in java
***************
Exception in java represent objects of some special category classes, which are called exception classes.

Each problem that occurs during runtime represents one object.

For e.g.   int i=10/0  ;   this statement contains a problem that is represented as an object of a class named
  ArithmeticException  (from java.lang package)

int num[] = { 10,20,30};
num[5] = 25;  // index does not exists    ArrayIndexOutOfBoundsException
  
Customer c1 = null;
  c1.custId =1234 ;  // c1 is null,   NullPointerException


Java Exception class hierarchy
*************************
 At the top there is  Throwable 

 Throwable ===>  Exception 
 Throwable ===>Error

Problems related to programming/application fall into Exception category ..  ArithmeticException, NullPointerException

Problems related to execution environment fall into Error category ..     StackOverflowError,   OutofMemoryError 


StackOverflow Error occurs if the stack is full, and similary OutofMemoryError occurs if heap is full.


Unchecked exception
******************
RuntimeException child classes and their child classes and child classes .. so on at any depth,  including RuntimException   are called unchecked exception


Checked  exception
*****************
All child classes of Exception class at any level of depth (except  RuntimeException class and it's sub hierarchy)  are called checked exceptions  



public class MyException extends Exception {

}
What happens when an exception  occurs? 
When an exception occurs  
  (i) JVM creates an object of a matching exception class, describing the problem
  (ii) JVM throws that object out of JVMs memory
  (iii) Stops/Terminates the program   by System.exit()



class Test {
  public static void main(String args[])  {
System.out.println("hello  world");
int i=10/0;
System.out.println("Good morning...");
}
}

What is exception handling ?
 It is way of preventing the JVM from stopping/terminating the program when an exception occurs.

How is exception handling achieved ?
  We make use of some special blocks of code related to exceptions.  These special blocks make use of exception handling keywords try, catch , finally.

The try block
*********** 
  It is a block of code, that we surround using the "try" keyword.
 e.g. 
    try {
             System.out.println("hello  world");
             int i=10/0;
              System.out.println("Good morning...");
        } catch(AritmethicExcepion e) {  // some code here }

What code does the try block contain ? 
 If we suspect any code that will possibly lead to exception, then we put that code inside the try block


The catch block 
*************
It is a block of code that we place immediately after the try block.   The catch takes one parameter which repreresnts any exception class name.

e.g.
   catch(ArithmeticException e) {  // some code here }

Work flow of try..catch

When an exception occurs by a line of code in the try block, JVM creates an object of matching exception class ,throws it to outside of the try block,  and then the catch() block receives it.

When catch block receives it, the program will not be terminated, and the JVM continues the execution from after the catch block onwards

There can be any number of catch blocks after a try block. Each catch block contains one exception  name

NOTE. From version 7 onwards, the catch block can contain more than one exception name each separated by  a  |

e.g.

  try {
   // some code here
  }   catch(ArithmethicException   |  NullPointerException | SomeOtherException   e)  {
    // some code here
   } 
 

There should not be any code in between the try and catch blocks

When an exception occurs in try block, and if the control jumps to catch block, after the catch block execution, the control will not jump back to try block

NOTE. In catch block, we can mention Exception which is the parent class that catches everything..


the finally block
************




File f = new File("hello.txt"); // this line is used to load the file
  try {
        int a = 10 / 0;
   } catch(NullPointerException e) {

   }
finally {
f.close();  // resource clean up code
}



the throw keyword
***************
It is used to throw an exception explicitly.   

To throw an exception explicitly ..  we can use "throw" keyword...

throw <exception object here>;

e.g. 
   NullPointerException e = new NullPointerException() ;
   throw e;

   ArithmeticException e = new ArithmeticException();
   throw e;

 AccountNotFoundException  e = new AccountNotFoundException(); 
    throw e;

 public class BankingOperationsImpl implements IBankingOperations {
 
     public void withdraw(BankAccount act, double howMuch)  {
               //  BankAccount temp =   some code here that reads the act nu
              if(act.getActNumber() !=1234) {
                  throw new AccountNotFoundException();
          }
     }

 }



Checked exceptions
****************

public class Test {
{
  public static void main(String args[]) {
  {
int a  =10/0;



}


public static void m1() throws FileNotFoundException {

File f = new File("http://192.168.10.12/hello.txt");

}

public static void m2()  throws FileNotFoundException{

    m1();
  
}
}


ip valid
server should be running
file should be there 


WRT  "checked exceptions",  we have two options
1. Either we have to try...catch blocks for that code,
2. OR we have to declare in the throws section of the method heading


NOTE. When making a call to a method which has exceptions declared in throws section of it's heading then, the calling code has to 
1. EITHER call the method in surrounding try catch..
2. OR the calling method has to redeclare the same exception in its heading

If we don't follow any of the above two options, then it will be a compilation error

public class Demo {
public void m1() throws SomeException {
    
}
}

DemoClient.java
 public class DemoClient {
   public static void main(String args[]) throws SomeException {
            Demo d1 =new Demo();  
         
	 d1.m1();
	
 }
 }



public class MyException extends Exception  {
 // some code...
}

class Demo {
  public void m1()  throws MyException 
   {
    // some code here
   }
    
  public void m2() throws MyException{

           m1();
  
  }
   public void m3() {
    m2();
   } 
}

User defined exception
********************
An exception that is defined by programmer is called user defined exception

Creating a user defined exception OR how do we define our own exception
**************************************************************
this is done by creating a class that extends ANY exception class.


e.g.1
   class MyException extends Exception {  }
e.g.2  class InSufficientFundsException extends Exception {  }
   e.g.3.  class  AccountNotFoundException extends Exception {  }

"Inside the user defined exception class, we have to override the toString() method."



12th April 2025
==================================================================================

Multithreading
************

Programming execution can be of synchronous and asynchronous

Synchronous execution means, the execution engine executes the code instructions one by one. it goes to the next line only when the current line of code is completed.

What is multithreading ?
 It is the ability of the execution engine (e.g. JVM, OS) to execute more than one thread concurrently.
NOTE. In reality the execution engine does not execute more than one thread concurrently, but it switches across the threads to utilize it's to the best

What is a thread?
  A thread defines a separate path of execution

Multithreading in Java
*******************
JRE is multithreaded environment, which means, behind the scenes JVM runs some threads for doing some job. for  GC

Java provides us the classes/interfaces/methods etc to develop multithreaded applications

Context switching
***************
It is the process where JVM switches from one thread to other thread during execution.
NOTE.  context switch does not happen ONLY if the current thread pauses.  Even though there is no reason to pause context switch happens

***Context switch also need time. which means, if there are too many threads, then JVM wastes its time switching than in executing****

The basic class and interface in java to work with multithreaded application

1. Thread class (this class is from java.lang  package)
2. Runnable interface (this interface is from java.lang package)


The Thread class few constructors, and methods
1. Thread()
2. Thread(String name)
3. Thread(Runnable r)
4. run()
5. start()
6. sleep()
***
***

How to create a new thread ?
  We can create a new thread  by
  (i) creating an object of the Thread class or an object of a child class of Thread class
  e.g.
           Thread t1 = new Thread();
           Thread t2 = new Thread();
       class SampleThread extends Thread {
            public void run() {
          // whatever code we mention here is loaded
          // on the newly created thread
          }
    }

             SampleThread t3 = new SampleThread();
In how many ways we can create thread in java ?





The run() method contains the code that need to be loaded on  to the newly created thread and executed there

After creating the thread, we need make the code of the run() method get loaded on to the thread, and get it executed. To do this, we make a call to start()  method.

t3.start();

 The start() method internally makes a call to the run method


The steps in developing a multithreaded program 
1.  Create a class that extends the Thread class and override the run() method inside it
2. Create an object of the class created in step 1
3. call the start() on the object created in step 2.
 
 class MyThread extends Thread {
     public void run() {
       System.out.println("I will be run on a separate thread");
    }
  }

  class Sample {
    public static void main(String args[]) {
      MyThread t1 = new MyThread();
       t1.start();
  }


NOTE, By default when the java code is launched for execution, JVM creates one thread automatically, and names that thread as main thread, and loads the code of the main method on that thread.




class SampleThread  implements Runnable {
    public void run() {

    }
    public void demo() {
  
    }
}

p s v m(....) {

SampleThread t1 = new SampleThread();
Thread x = new Thread(t1);
x.start();  // it will internally call t1.run()

}


Thread lifecycle
*************
During the creation and execution, a thread passes through different phases.  All these phases are called lifecycle phases.

New ==>Ready To Run ==>Running ==> (pause/dead)

NOTE. We cannot make a call to the start() method on thread more than once.
if we do so, it results in an exception,  "IllegalThreadStateException"

The sleep() method.
***************
 public static void sleep(long ms) throws InterruptedException

Thread.sleep(1000)


synchronization is a mechanism which is used to achieve thread safety in case of resource clashes where more than one thread works with the same code on the same object at the same time.

synchronized keyword

the Object class.
java.lang package
It is the super class of all classes
It has various methods (a few methods used in multithreading)

toString() : This method returns a string.
This method is usually used to return the object description such as printing values of the variables in the object

equals() hashCode()


How can Object's class's author write the code for the equals() method in such a way, that when some one extends Object class and inherits it's equals(), compare the equality of the objects

The default built in functionality of the equals() method in Object class, is to check whether two object references point to the same object in memory

Product p1 = new Product(1,"A");
Product p2 = new Product(1,"A");
Product p3 = p1;
  System.out.println(p1.equals(p2)) ;  // not pointing to the same object in memory, therefore we get false
  System.out.println(p1.equals(p3)) ;  // pointing to the same object in memory, therefore we get true


As a developer, we have to override the equals() method of the object class in such a way that it checks the values of the two different objects of the same class for equality .

Product p1 = new Product(100,"S25-Ultra");
Product p2 = new Product(100,"S25-Ultra");
	System.out.println(p1.equals(p2));

public class Product extends java.lang.Object{
 private int prodId;
 private String prodName;
 
 public boolean equals(Object ob) {
  // inside this method    ob means p2, p2 is translated to temp,   this means p1
  temp means p2
  this means p1
  }

}

  Object ob = p2;
Product temp =(Product) ob;

The hashCode() method.
********************
By default the hashCode() method that is in Object class returns the memory location where a particular object is stored

But the real purpose of hashCode() real meaning of hashCode() in programming is something different.

We should override equals() hashCode()  toString() of the Object class in the entity/dto classes such as Employee, Customer, Product

The Comparable interface
***********************
This interface one abstract method, the compareTo() method.

This method is used to compare the objects against their natural order..
   Hello   Good morning   
    34  23 57 

NOTE, The equals(), hashCode(), compareTo() method are used internally by the collection framework related classes such as LinkedList, ArrayList, ... Hashtable, HashMap, ....


String, StringBuffer, StringBuilder classes are used to create and manipulate strings. all these are from java.lang package

String objects are immutable,   StringBuffer and StringBuilder are mutable

StringBuffer is thread safe, StringBuilder is thread-unsafe

String constant pool stores the String s created using = 

Java collections
**************
What is a collection ? 
 It is a group of objects.

Generics
********
This is a collection which contains objects of the same class (homogenous)

Non generics
************
This collection contains heterogenous elements

What are collections used for?
  They are used to transfer bulk number of objects from one part of the application to other

What is java collection framework ?
  It is a set of interfaces, and the classes that implement these interfaces from java.util and it's related packages

java.util
java.util.concurrent

Iterable==>Collection===> (List, Set  interfaces)

Iterable==>Collection===> List===>  (LinkedList, ArrayList, Vector --- classes)

Iterable==>Collection===> Set ===>(TreeSet, HashSet, LinkedHashSet -- classes)

A few methods of the java.util.Collection

boolean add(Object ob)
boolean remove(Object ob)
boolean  contains(Object ob)
boolean isEmpty()
int size()
void clear()
Iterator iterator()




Steps in working with a collection
*****************************
1. create a collection object of required type
	List<Integer> intList1 = new ArrayList<Integer>();
2. Add the objects into that.
		intList1.add(34);
		intList1.add(50);
		intList1.add(56);
3. then perform various operations like searching, removing, iterating, clearing, finding size....


14th April 2025
==================================================================================

contains() remove() and similar method operations on collections like ArrayList, LinkedList,   etc  rely on the equals() method for successful working.

currentElement will  0th, 1st, 2nd, so on, on each iteration
searchElement is the object that we supply to contains() and remove() method
for(i=0;i<prodList.size();i++) {
    if(currentElement.equals(searchElement) {
         return true;
         break;
    }  
}

NOTE.
******
All wrapper classes, String, StringBuffer, StringBuilder internally implement the equals() and hashCode() method.

ArrayList, LinkedList


NOTE.  The add() of the TreeSet internally uses the compareTo() method of the class whose objects are added to the add() method.

Set<Integer>  intSet  = new TreeSet<>() ;
		intSet.add(35);
		intSet.add(1);
		intSet.add(56);
		intSet.add(2);
		intSet.add(1234);


  35.compareTo(56);    -1




ArrayList, Vector ==>  use array data structure internally
whereas, ArrayList is thread-unsafe and Vector is thread safe

When should we use ArrayList over Vector ?
******

LinkedList  internally uses doubly linked list

TreeSet  implements tree data structure

HashSet  internally implements hashing

All List implementations are ordered collections, means, the elements stored in these collections  maintain the insertion order .   ArrayList, Vector, LinkedList

TreeSet is a sorted collection , means elements are stored in sorted order in the TreeSet  (Comparable compareTo)

Hash* related collections are  UN-ORDERED and UN-SORTED

Almost every collection class has more than one version of the constructor



LinkedList  lst1 = new LinkedList();
 lst1.add(3); 
 lst1.add(6);
 lst1.add(1);

ArrayList lst2 = new ArrayList(lst1);

List interface classes have additional feature as opposed to Set interface classes

i.e.  We can perform index based operations such as 
 index based operations such as get(int index)  remove(int index)



Looping through the elements
*************************
There are 3 ways.

1.  The legacy way using iterator() and Iterator
2.   The enhanced for loop
3.  Java 8 introduced forEach() stream operation

The java.util.Iterator interface.  Methods of this interface are used to loop through the elements of a collection

A few methods of this interface
1.  T  next()  :  returns the next available object from the current pointer position
2.   boolean hasNext() : returns a boolean indicating whether there is a next element
3.  void remove(); removes the element at the current pointer position 

List<Integer> intList1 = new ArrayList<Integer>();
		intList1.add(34);
		intList1.add(50);
		intList1.add(56);
		intList1.add(400);
		intList1.add(30);

Iterator<Integer>  itr =  intList1.iterator();
while(itr.hasNext() ) {
   Integer temp = itr.next();
   System.out.println(temp);
}
 itr =  intList1.iterator();

while(itr.hasNext() ) {
   Integer temp = itr.next();
   System.out.println(temp);
}

for(Datatype/Classname temp :  arrayname/collectionname) {
  // process the object here
}

for(Integer i :  intList1)  {
   System.out.println(i);
}

intList1.forEach(System.out::println) ;

strList.forEach(System.out::println)

prodList.forEach(System.out::println)

The main difference between List and Set is that  All List implementation classes (ArrayList, Vector, LinkedList)  the allow duplicate elements.   where as, Set implementation classes (TreeSet, HashSet ...)  does not allow duplicate elements in the collection.

Set<Integer>  s = new TreeSet<>();
   s.add(100);    
   s.add(100);
NOTE. If we add duplicate element to a Set, then it won't result in compilation failure or runtime failure, simply the duplicate added one is ignored

The Comparator interface.   This is from java.util package.  This is closely similar to Comparable interface with respect to functionality , but it is used in a different way.

The Comparator is used when we want to sort an object based on more than one property.

The Comparator has a method called  int compare(Object f, Object s)

The java.util.Collections class
************************
This is a utility class which contains various useful methods. The most popular method is sort(). 

All the methods of the Collections class are static.

Collections.sort( some collection name here); 

The above method sorts the given collection.  To sort the collection, the class of the objects stored in that collection should implement the Comparable interface other wise the sort() method throws an exception...

Collections.unmodifiable***() methods are used to create a read only version of a collection or a map

Collections.synchronized***() method are used to create thread safe version of a collection or map


the java.util.Arrays

Arrays.asList()

Arrays.sort()

    List<Product>   list2 = Arrays.asList(  new Product(....), new Product(....) , ....) ;
       Arrays.sort(list2);

com.collections.crud.dvo
com.collections.crud.service
com.collections.crud.dao
com.collections.crud.client
com.collections.crud.exceptions

Develop the layered architected based CRUD operations... for the above mentioned 

Product
 *****
  prodCode
  prodName
  price
// constructors, getters, setters, comparable, equals, hashcode, toString



15th April 2025
==================================================================================


standalone java application, it means, the execution starts from p s v m

public class UserDetails {
   private String username;
  private String password;
// rest of the code..
}


public class Demo {
   public static void main(String args[]) {
     List<String> lst = new ArrayList<>();
    lst.add("hello");  lst.add("java");  lst.add("react js"); lst.add("angular");

     lst.set(index, new object);
     lst.set(2,"React JS");
}
}



Java version 8 features
******************
1. functional interfaces and lambda expressions
2. Optional class
3. stream api
4. method references
5. default methods and static methods in interfaces
6. date time api


What is a functional interface ?
  An interface with ONE and ONLY ONE abstract method is called functional interface.

Java comes with many in built functional interfaces and in addition to that, we can declare our own functional interfaces.

Lambda expression: it provides a shortcut syntax to implementing the functional interface.


public interface Runnable {
 
  public abstract void run() ;
}

Runnable r = ()->System.out.println("hello");

new Thread(r).start();



new Thread( ()->System.out.println("hello")).start();

Lambda expressions can be passed into a method as a parameter

Lambda expressions can be returned from a method, if the a method return type is a functional interface


Java 8 onwards, there are various built in functional interfaces...
java.util.function

Function  -  R apply(T  t)
BiFunction
Supplier
Consumer    void accept(T t)
Predicate
BiPredicate
BiSupplier
BiConsumer

The aforementioned functional interfaces are used as parameters in java stream api operations

The Optional class
***************
This class helps in working with nulls in an easy readable way

String s1= null;
if(s1 !=null) {
  System.out.println(s1.length());
}



Method references
***************
It provides even more short cut syntax to a lambda expression.
If the lambda expression code contains a single statement, and if that statement is a method call, and if the number parameters and type of the parameters of that method call , matches with the number of input parameters and type of input parameters, then we can use method reference

public interface Greet { 
    public abstract void wish(String name) ;
}
public static void main(String args[]) {
    Greet g1 = (name)->System.out.println(name);    // regular syntax
     Greet g2 =  System.out::println ;  // method reference syntax
}


16th April 2025
==================================================================================
Copy and paste the Product.java from collections-crud project to java8 features project
Now demonstrate the usage of working with Optional class that 
(i) create an optional class object with value of Product object  with some prod code, name and price
    display it's details by using the get() method of optional class
(ii) create one  more optional class object with value of empty,
     now demonstrate, orElse() with an alternate product object, because the optional is empty
 

public interface Circle {
  public abstract  void area(double radius) ;
}

CircleMain1
   p s v m () {
   demonstrate the lambda expression for Circle interface area() method and call the method

}

}






1) Functional interface.  An interface with a single abstract method is called functional interface.
NOTE. Functional interface MUST contain ONE and ONLY one abstract method.

e.g. @FunctionalInterface
      public interface Circle {
            public abstract void area(double r) ;
   }

   @FunctionalInterface, if declared on top of an interface, it will cause a compilation error, if the interface contains 0 or more than 1 abstract method.

   @FunctionalInterface
public interface Fullname {
   public abstract String showFullname(String fname, String lname);
}


   public interface Circle {
            public abstract double area(double radius) ;
   }
   

   public class Example1 {
       public static void main(String args[]) {
            m1(  radius-> Math.PI*radius*radius     );
     }   
   
   public static void m1(Circle c) {
          double a = c.area(2.3);
	 System.out.println("Area = " + a);		
     }
   }
          


                 


Lambda expression:  It is a syntax which allows us to implement the code for the method of functional interface without declaring a separate java class.
 The syntax to use the lambda expression is as below
   


   @FunctionalInterface
public interface Fullname {
   public abstract String showFullname(String fname, String lname);
}

Fullname  x = (f,l) -> f+" " + l;

 String fullname = x.showFullname("Scott", "Urman");



Java 8 onwards, there are various built in functional interfaces...
java.util.function

Function  -  R apply(T  t)
BiFunction
Supplier
Consumer    void accept(T t)
Predicate
BiPredicate
BiSupplier
BiConsumer


public interface Function {
     public abstract  R  apply(T t) ;
}


public class Demo implements Function<String,String> {
public String apply(String s) {
      return s.toUpperCase();
 }
}
    s->s.toUpperCase();


The Optional class  
 This is from java.util package and is used as an alternative to the legacy style null checks

for e.g.  consider the following code
     String s1=null;
        if(s1==null) {
		s1="hello";
        }
the above code snippet can be written using Optional as follows
      Optional<String> s1 = Optional.ofNullable(null);
        System.out.println(s1.orElse("hello"));

Method references
***************
It provides even more short cut syntax to a lambda expression.
If the lambda expression code contains a single statement, and if that statement is a method call, and if the parameters , types, and  return type of the method call matches with the  parameters, types, return type of the method in the functional interface then we can use method reference
classname::method-name   in case of static methods
object::method-name  in case of non static methods
classname::new  in case of new operator (constructor)

 
public interface Greet { 
    public abstract void wish(String name) ;
}


Greet g1 = (name)->  System.out.println(name);
Greet g2 = System.out::println  ;

Java 8 streams
*************
From version 8 of java, there is a concept called streams and stream api

What is a stream?
 A stream is a sequence of objects (elements) in memory
   OR
A stream is flowing sequence of data items in memory
  OR
 A stream is a data set (e.g.  a group  of Strings,   a group of Integer s ,  a group of Product s) in memory


Why do we need streams ?
We use streams to process the data (objects) using some special functions related to stream, stream API

What is a stream operation ?
  It is a piece of code (or a function) that applies the given logic on the each element that is in the stream

Stream operations are of two types
*****************************
Intermediate operations :  These are the functions (operations)  which take the stream element , apply some code/logic on that element, and send that element to the next stream operation in sequence
in other words, the intermediate stream operations,  process stream elements, and produce the new stream
   map, filter, sorted, skip, distinct 
Terminal operations
A terminal operation is that which does not produce one more stream. A terminal operations does the things like collecting the elements which are processed by intermediate operations into a collection, or print them, etc   count, min, forEach, collect 


How to create a stream
********************
Streams can be created using a variety of ways.
1. From a collection
   List<String>  strlist1 = Arrays.asList("Java", "React JS" , "Python") ;
   Stream<String> stream1 = strlist1.stream();
int marks[] = {  67,78,65,89};
  IntStream  intstream = Arrays.stream(marks);

String names[]= { "Scott", "Smith", "Allen", "Mike"} ;
 Stream<String>  stream2 = Arrays.stream(names);

2. Using Stream.of()
  Stream<String>  s1 = Stream.of("iPhone", "S25", "Realme");
   Stream<Product>  s2 = Stream.of( new Product(1,"A",100) , new Product(2,"B",110) );
  

17th April 2025
==================================================================================

java.lang    Comparable   int  compareTo(Object ob)
java.util   Comparator    int compare(Object ob, Object ob2)


JDBC
****
Java Database Connectivity

What is JDBC ?
  It is a collection of interfaces, classes, methods which are used by a Java program to connect to database and perform CRUD operations

JDBC concepts
*************
1. JDBC Driver:   It is a program ( a bunch of programs) which acts as mediator between the Java code and the DB server

As a mediator, what does the driver do ?
  it establishes the connection between java code and db server
  it sends SQL statements from java code to db server and returns the results of SQL statement execution from db server 
 it tranlates java data types to db data type and vice versa

2. JDBC url:  It is a string which contains the details of the  DB SERVER
     type of the jdbc driver
     which database 
     IP address
     db instance name

     jdbc:mysql://localhost:3306/test

 JDBC URL is required and is used to connect to a DB server

3.  JDBC API
    java.sql
        DriverManager  - C
        Connection  - I 
        Statement  -  I
         PreparedStatement  - I
         CallableStatement   -   I

 Almost every method of every interface and every class in JDBC declare SQLException
   Class.forName(" here we need to mention the .class file name along with it's package name")

    try {
    Class.forName("com.ex1.A");
   Class.forName("banking.hdfc.Demo");
    Class.forName("com.mysql.cj.jdbc.Driver");
    
    } catch(ClassNotFoundException e) {   };


What is a JAR file ?
  It is a compressed file which contains packages
  packages  contain .class files



Step-1   Add the relevant JAR  file
Step-2  use the  Class.forName("com.mysql.cj.jdbc.Driver"); 
  luckily step-2 is automatic 
Step-3 :  Write down the code that establishes a connection between Java and DB
For this step we make use of a class called "DriverManager"
String url ="jdbc:mysql://localhost:3306/test";
String username="root"
String password="Mysql@123";
      Connection   cn =  DriverManager.getConnection(url, username, password)

Step-4
  Create an object of Statement or PreparedStatement
   PreparedStatement pst = null;
 String insertCommand = "INSERT INTO product VALUES (?, ? ,? ) ";

       pst = cn.prepareStatement(insertCommand);
Step-5; 
     write down the code that fills the ? marks with actual values.
      pst.set***(? index number, value);
      pst.setInt(1,101);
      pst.setString(2,"S25");
      pst.setDouble(3,2500.00);
Step-6.  Execute the SQL command prepared in step-5
     pst.executeUpdate();

Login to MySQL console or workbench


CREATE TABLE product(prodcode int, prodname varchar(20), price double(7,2) );


Fetching Records steps
*******************
1.  Add jar file (if not already added),  load driver (if not already loaded), get connection (if not already), create preparedstatement (if not already)

2.  Declare a string for the select statement.
    String selectCommand = "SELECT * FROM product ";
3.  execute the method  executeQuery() on the PreparedStatement object pst;
                 ResultSet  rs = pst.executeQuery(selectCommand);

4. Process results using  rs.next() and rs.get***() methods where * is replaced with matching data type of the column
	e.g. 
                   int prodcode = rs.getInt("prodcode");    String prodname=rs.getString("prodname");
                   double price = rs.getDouble("price");
                    Product p = new Product(prodcode, prodname, price);
                       prodList.add(p);
      


Maven
*****
What is Maven ?
  It is a build and dependency management tool

What is build ?
  It is the process of executing the tasks like cleaning, compiling, testing, packaging, installing
 clean compile test install package 
What is dependency management ?
  It is the process of automating the download and linking of the dependencies (JAR files)

a.jar  --  artifactId ,  groupId ,version ,compile/runtime/test

pom.xml  (Project Object Model)




   <dependencies>
 <dependency>
   <groupId>abc</groupId>
   <artifactId>a</artifactId>
  <version>1.0</version>
  <scope>compile</scope>
 </dependency>

<dependency>
   <groupId>abc</groupId>
   <artifactId>a</artifactId>
  <version>1.0</version>
  <scope>compile</scope>
 </dependency>
<dependency>
   <groupId>abc</groupId>
   <artifactId>a</artifactId>
  <version>1.0</version>
  <scope>compile</scope>
 </dependency>
<dependency>
   <groupId>abc</groupId>
   <artifactId>a</artifactId>
  <version>1.0</version>
  <scope>compile</scope>
 </dependency>

<dependency>
   <groupId>abc</groupId>
   <artifactId>a</artifactId>
  <version>1.0</version>
  <scope>compile</scope>
 </dependency>

<dependency>
   <groupId>abc</groupId>
   <artifactId>a</artifactId>
  <version>1.0</version>
  <scope>compile</scope>
 </dependency>

<dependency>
   <groupId>abc</groupId>
   <artifactId>a</artifactId>
  <version>1.0</version>
  <scope>compile</scope>
 </dependency>

<dependency>
   <groupId>abc</groupId>
   <artifactId>a</artifactId>
  <version>1.0</version>
  <scope>compile</scope>
 </dependency>



  </dependencies>












JUnit
****
It is a unit testing framework for java

What is unit testing?
  It is a process of writing some code to test whether some other works as expected

To work with Junit, we need to add the relevant dependencies.

JUnit annotations
**************
   @BeforeAll   @AfterAll  @BeforeEach  @AfterEact   @Test

@BeforeAll 
We declare a method with this annotation, if we want some code to be executed before all @Test methods. This method is executed only once before all @Test method.   NOTE. This method should be public static void and should not declare any throws

@AfterAll 
We declare a method with this annotation, if we want some code to be executed after  all @Test methods. This method is executed only once after all @Test method.   NOTE. This method should be public static void and should not declare any throws

@BeforeEach 
We declare a method with this annotation, if we want some code to be executed once before each @Test method

@AfterEach 
We declare a method with this annotation, if we want some code to be executed once before each @Test method

@Test
This used to mark a method as Junit test method

@ParameterizedTest
This used to mark a method as Junit test method which takes parameters. This needs additional support of @ValueSource annotation that supplies values to the test parameter

@DisplayName This is descriptive purpose. We can change the name of the test method that is displayed in the console.


   public class ExampleTest {

  @BeforeEach
     public void init() {

   }

 @AfterEach
  public void clear() {

   }
     @Test
     public void testM1() {

     }
 @Test
     public void testM2() {

     }
     @Test
     public void testM3() {

     }
 @Test
     public void testM4() {

     }
  } 


JUnit Assertions
*************
assertions in JUnit are methods which are used to test the expected result of a code execution, A few assertions

assertEquals()   : This is used to check whether the expected output is same as the output produced by a method/code execution. If the produced (actual) output is different from the expected output the it means the test is fail  
assertTrue( )  : This is used to check whether the value given to this assertion is true.  if the value given to the assertion is false, then it means the test is fail. otherwise test is pass
assertFalse( ) This is used to check whether the value given to this assertion is false.  if the value given to the assertion is true, then it means the test is fail. otherwise test is pass
assertThrows() 
This is used to check whether a particular piece code execution throws an expected exception.  It the code execution throws the expected exception then it means the test is pass else the test is considered as failure
assertArrayEquals()
This is used to check whether the elements of two different array are equal. if the elements of both the arrays are same, the test is pass, else fail






MySQL
MongoDB
VsCode
node js
Git
IntelliJ / STS

  JaCoCo ==   Java Code Coverage

Right Click Project --> Maven --> Update Project - > Finish


Hibernate JPA
***********
What is ORM ?
  ORM full form is Object Relational Mapping

What is Object Relational Mapping ?
  It is the process of mapping an object in an OOP language to a matching record in Relational database table

ORM Tool ?
 It is a software or library or framework, which automates the process of  CRUD operations by automatically generating the database connectivity and related code.

Load the driver class,  Establish a connection, Declare all the SQL commands as required,  create a PS,  execute the sql commands on the PS, process the results

One such popular tool for java is something called Hibernate

what is hibernate ? 
 It is an ORM tool for java

Hibernate provides its functionality in two different products (or libraries)

A library or a framework is a collection of jar files
A jar file is a collection of packages
A package is a collection of interfaces, classes, constants,  enums etc

1. Library is called hibernate core
2. Library is called as hibernate JPA  (Java Persistence API)
  JPA is a collection of  interfaces, classes, constants,  enums etc provided by hibernate.

Why do we use JPA ? 
 Using it, we can reduce the amount of database code(JDBC code) in order communicate with the database

The different parts of a JPA application
1. Entity classes and their objects
2. JPA api.   (interfaces and classes )
3. persistence.xml

What is an Entity class ?
  An entity class is a that whose objects when loaded into memory are physically connected to the matching record.
 Entity classes are declared with @Entity annotation and entity class variables/fields are declared with @Id, @Column annotations
 @Entity 
 @Table(name="emp_tbl")
public class Employee {
    @Id
    private int empId;
    @Column
    private String empname;
 }

JPA: These are set of interfaces and classes. 
  EntityManager interface:  Methods of this interface are used  to perform DB operations such as adding , deleting, updating, finding, querying...       em.persist(new Employee(1,"A","Developer"));

EntityManagerFactory interface:   Methods of this interface are used to create an object of EntityManager

EntityTransaction :  This interface has methods to commit, rollback the transaction



persistence.xml
*************
This file contains the details about the JDBC properties such as driver class name, username,  pwd...



1.  created a maven project
2.  in the pom.xml, we have update the java compiler to 1.8 or higer
3.  from the google search, we searched for hibernate core maven,  opened the first result link, chosen hibernate core 7.0.0Aplha3 , copied it and pasted it the dependencies of pom.xml
4.  like in step 3 we searched for my sql connector java, chosen second link,  8.028, copied pasted in pom.xml
5.  created a new folder META-INF under src/main/resources
6. create a file named persistence.xml in META-INF folder
7. copied and pasted the content from chat box into the file created in step 6

use test;
drop table product;
8.  created a package com.jpa.examples
9.  create  a class in that package,  Product



21st  April 2025
==================================================================================

What is ORM ?
What is JPA ?
The various concepts like what is entity class ? what is @Entity ? GeneratedValue,  
What is  EntityManagerFactory ?  What is EntityManager ?  EntityTransaction ?

Steps to develop a JPA application and crystal clear meaning of each step and each line of code ?
and anything related to this topic




20 tables
Each table has an average of 5 columns

INSERT , UPDATE, DELETE - 
 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()  
pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***() 
 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()

 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()  
pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***() 
 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()

 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()  
pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***() 
 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()

 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()  
pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***() 
 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()

 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()  
pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***() 
 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()

 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()  
pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***() 
 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()

 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()  
pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***() 
 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()

 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()  
pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***() 
 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()

 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()  
pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***() 
 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()

 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()  
pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***() 
 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()

 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()  
pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***() 
 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()

 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()  
pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***() 
 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()

 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()  
pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***() 
 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()

 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()  
pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***() 
 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()

 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()  
pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***() 
 pst.set***()  pst.set***() pst.set***() pst.set***() pst.set***()

 for 20 tables
 What is an ORM tool ?
 It is a software or library or framework, which automates the process of  CRUD operations by automatically generating the database connectivity and related code.

What are some popular ORM tools for Java ? 
  Hibernate native/core --  SessionFactory/Session
  Hibernate JPA  -- EntityManagerFactory/EntityManager

In the above mentioned names Hibernate the company which has two tools  (i) core (ii) JPA
What is hibernate JPA?
interfaces, classes, annotations, built in jdbc properties etc which we use to automate the process of JDBC code

The main interfaces and their roles.
1. EntityManager interface.  The methods of this interface are used to perform DB tasks such as adding new record, deleting existing record, updating records,  querying records etc... 
        persist() : This method is used to create a new record if it does not already exists, or else it updates.
        remove(): this method deletes a record
        

To call the afore mentioned methods, we need an object of a class that implements the EntityManager interface 

EntityManager em = here we need some code that creates an object of the class that implements the EntityManager interface

EntityManager em = emf.createEntityManager();    the createEntityManager() method internally contains the code that creates an object of the class that implements the EntityManager interface

2. EntityManagerFactory : It is an interface.   This interface is responsible for creating an object of a class that implements EntityManager

   EntityManagerFactory  emf = Persistence.createEntityManagerFactory("here we need to provide various details, e.g.  url, username, password, driver class, persistence provider, to display or not to display sql commands, to format or not to format sql commands, to generate CREATE / ALTER/DROP commands,  the list of classes which are mapped to tables  etc....")


   EntityManagerFactory  emf = Persistence.createEntityManagerFactory("persistence.xml")

src/main/resources/META-INF


3. What is an entity class ? 
  It is a class whose objects are linked/mapped to records in a table
 In order for JPA to MAP an object to a table,  and then perform DB operations , the object needs to be marked with @Entity annotation for its class and fields with relevant annotations

e.g.
    @Entity
     public class Product {
	@Id                // this annotation marks prodId as a variable which is mapped/linked to prodId PK in 				//the table
       @GeneratedValue(strategy= GenerationType.AUTO )
           int prodId;  --- this o

   @Column (name="prod_name") // this annotation maps the prodName variable top prodName column
           String prodName;
   }
    Product p1 = new Product(10,"A");
     em.persist(here we need to provide an object of  a class that is marked with @Entity annotation)

  em.persist(p1);  // when this line is executed, internally the following JDBC code will be generated and executed.

  1. Load the driver class  Class.forName(com.mysql.cj.driver.Driver)
2. get a connection to Database 
  Connection cn = DriverManager.getConnection(url, username, pwd);
3.  Prepare a statement object with some SQL stored in it 
PreparedStatement pst= cn.prepareStatement("INSERT or UPDATE or DELETE or SELECT");
4.   execute the SQL statement  stored on the pst in step 3
      pst.setInt(1,10) pst.setString(2,"A");    pst.executeUpdate()



where all the afore discussed interfaces, classes, annotations, properties .. etc are available.

XYZ jar file from the owner of that jar file

Querying with JPA (working with data fetching  OR select  statements using JPA)
1.  Either we have to write down the SELECT queries manually and execute them
2.  OR we can use some special feature called Criteria API (very complex)


1.  In order to write the SELECT queries manually, we have two types of QL 
   (a) Native SQL :  this means, the standard SQL that we use for MySQL, Oracle, MsSQLServer etc
  (b) JPQL : Java Persistence Query Language
   In this QL, the syntax of the SELECT statements is mostly same as the syntax of SQL
  the difference  is  
   SQL refers to column names in select clause and table names in from clause
   WEHRE AS  in JPQL,     it refers to variable names in select clause and class names in from clause

Note. In case of JPQL , we don't have * symbol in the select statement, if we want to use *, we have to use table alias

What is the use or need of JPQL while we already have the native SQL ?


Relationship mapping in JPA 
***********************

What is relationship mapping?
It is an approach using which , we map the parent-child relationship that exists between tables in the database such as MySQL, Oracle .. to be in sync with between the matching java @Entity classes in JPA.

for e.g.  
     Dept                      Emp
**********              ********
   deptid  pk               empid pk
   dname  vc               empname vc
   ----                          deptid   fk (to the deptid fk of dept table)

@Entity                                   @Entity
public class Dept {                    public class Emp {
@Id                                             @Id
@GeneratedValue			@GeneratedValue
private int deptid;                      private int empid;
private String dname;                 private  String empname;
@OneToMany
private List<Emp> empList;         ----   
cons/getters/setters/eq/hash      cons/getters/setters/eq/hash 
}                                               }




Dept d1 = new Dept(1,"Sales" ,new ArrayList<>);
d1.getEmpList().add(new Emp(101,"Scott"));
d1.getEmpList().add(new Emp(102,"Smith"));
d1.getEmpList().add(new Emp(103,"Allen"));

em.persist(d1);  // this will add d1 into Dept table, and 101,102,103 Emp records into Emp table


for e.g.  
     Dept                      Emp
**********              ********
   deptid  pk               empid pk
   dname  vc               empname vc
   ----                          deptid   fk (to the deptid fk of dept table)

@Entity                                   @Entity
public class Dept {                    public class Emp {
@Id                                             @Id
@GeneratedValue			@GeneratedValue
private int deptid;                      private int empid;
private String dname;                 private  String empname;
						@ManyToOne
                                                 private Dept dept;
cons/getters/setters/eq/hash      cons/getters/setters/eq/hash 
}                                               }




for e.g.  
     Dept                      Emp
**********              ********
   deptid  pk               empid pk
   dname  vc               empname vc
   ----                          deptid   fk (to the deptid fk of dept table)

@Entity                                   @Entity
public class Dept {                    public class Emp {
@Id                                             @Id
@GeneratedValue			@GeneratedValue
private int deptid;                      private int empid;
private String dname;                 private  String empname;
@OneToMany                              @ManyToOne
private List<Emp> empList;         private Dept dept;  
cons/getters/setters/eq/hash      cons/getters/setters/eq/hash 
}                                               }



What is spring ? 
 It is a collection of various projects from the team in spring 

e.g.  project names
 spring framework=   CORE, CONTEXT, AOP, MVC, JDBC, ORM, JMS
 spring data = Data JPA, Data Mongo
 spring boot = It is a tool that helps to develop microservice based applications.
 spring session =  It is used to work with session management
 spring cloud = it provides the implementation for various microservices patterns
 spring security = It is used to apply authentication and authorization
 
Each project is EITHER divided into sub projects OR modules

What should we learn first in the spring eco system ?
  We should learn spring framework first .

What is spring framework ? 
 It is a framework that simplifies the development of Java SE or Java EE applications

How does it simplify ?
  By the use of POJO based programming.

What is POJO? 
  Plain Old Java Object.  It is an object of a class that neither extends any in built class nor implements any in built interface.

Why use spring framework ?
  It provides the functionality of something called DEPENDENCY INJECTION

What is DEPENDENCY INJECTION ?
  It is a design pattern.
  
What is a design pattern ?
  A design pattern defines a solution to a problem. It means, a design pattern, defines how a particular problem should be solved effectively

To what problem, does the  DEPENDENCY INJECTION pattern provides a solution ?
It provides a solution to acquiring dependencies required by a consumer, by the process of loose coupling
(In other words DI solves tight coupling issues)

In the context of  DEPENDENCY INJECTION  there are 3 roles
1. Dependency consumer :
      It is an object which DEPENDS on some other object to complete its functionality
2. Dependency
      It is an object which is required by a DEPENDENCY CONSUMER
3. External object (we can call this with other names like  container/framework object)

The problem or the question ?
  
How does a DEPENDENCY CONSUMER acquire the DEPENDENCY that it needs ?
a) does the DEPENDENCY CONSUMER hard code the object creation of the DEPENDENCY using new operator and constructor WRT java and WRT whatever applicable syntax in non java?

public class InMemoryProductService implements ProductService {
  private ProductDAO  dao ;D
}

b) is there any  EXTRA/EXTERNAL object creating the DEPENDENCY and passing it into the DEPENDNECY CONSUMER ?


public class  External {
    ProductService  ps = new InMemoryProductService();  // creating consumer object
    ProductDAO  pdao = new OracleDao();   // also creating dependency object
    ps.setPdao( pdao );    // injecting dependency into the consumer

}



Spring framework concepts
***********************
1. Bean (also called spring bean)
A bean is an object in a spring enabled application.   e.g.   object of InMemoryProduceService,  InMemoryProductDAO,  OracleDao,  BankDao

2. Spring enabled application.
  It is an application that is developed by making using of spring framework and relevant projects

3. Container  (container creates the beans)
   It is an object that 
   (i) creates dependency consumers
   (ii) also creates dependencies
  (iii) injects dependencies into consumers

The role of the "container" in spring framework is provided by the objects of implementation classes of something called ApplicationContext interface which is a built in interface in spring framework

ApplicationContext
   ClassPathXmlApplicationContext 
   AnnotationConfigApplicationContext
   XmlWebApplicationContext

 ApplicationContext ctx = new ClassPathXmlApplicationContext ("sample.xml") ;
where in sample.xml contains a list of bean declarations using XML tags

22nd  April 2025
==================================================================================

Dependency Injection (DI) is a design pattern in object-oriented programming that promotes loose coupling and modularity by providing a class with its dependencies (objects it needs to function) externally, rather than creating them internally

How does dependency injection work ?

In DI, we make use of an external object to 
(i) create objects of the dependency consumer class
(ii) create objects of the dependency class
(iii) to inject the  dependency  into the dependency consumer

The code that creates the and injects the dependency into the consumer will not be a part of the consumer class, rather it will be handled separately by the external object from a separate file

Who creates the beans ?
 spring container

"If container creates the beans, shouldn't it know about what beans it has to create, and what beans it has to inject into consumer beans"

Spring Bean configuration, what is it ?
******************************
It is the process of declaring/defining a list of class names of the dependency consumers,  class names of the dependencies, and the details about  which dependency needs to be injected to which consumer.

Spring configuration can be done in one of the following 3 ways or  mix of the following 3 ways
1. XML configuration : this has not been in use since the last few years(may be since the last 7 to 8 years)
2. Java Config based configuration
3. Stereo type configuration:  This is done using some annotations called "stereotype annotations"
  @Component @Repository @Service @Controller  These annotations are used on top of the class declarations
 e.g.

@Component
public class  OrderProcessor {

}

@Controller   public class ProductController {

 }
  @Service      public class ProductService {

 }
     @Repository   
   public class ProductDAOImpl implements ProductDAO {

     }

@Repository : This annotation is used to declare a DAO class object as a spring bean in the spring container
@Service : This annotation is used to declare a service class object as a spring bean in the spring container
@Controller: this annotation is used to declare a controller class object as a spring bean in the spring container
@Component:  To declare a class (which is other than dao, service, controller) as a bean we use this annotation


NOTE. When using the stereo type annotations, we need to tell the spring container to scan for the packages and java files and execute the stereo type annotations if any


@ComponentScan(basePackages={"package1",  "package2", .......} })
public class MyConfig {

}


com.spring.stereo.ex1


XML file example
**************
mybeans.xml
***********
<bean id="ns1"  class="WhatsAppNotificationSender" />
<bean id="ns2"  class="EmailNotificationSender" />
<bean id="ns3"  class="MessgageNotificationSender" />

<bean id="chk1"  class="CreditCardCheckout" />
<bean id="chk2"  class="DebitCardCheckout" />
<bean id="chk1"  class="NetbankingCheckout" />

<bean id="op1"  class="OrderProcessor" >
   this is the place of the code where we mention the details of the orderprocessor dependencies
  <property name="sender"  ref="ns2"/>
  <property name="checkout"  ref="chk2"/>
</bean>

Java Config approach
*****************
public class MyBeansConfig {
// here a list of methods that create the beans using the new operator

@Bean
public NotificationSender   ns1() {
   return new WhatsAppNotificationSender();
 }
@Bean
public NotificationSender   ns2() {
   return new EmailNotificationSender();
 }

@Bean
public NotificationSender   ns3() {
   return new MessageNotificationSender();
 }
@Bean
public Checkout   chk1() {
   return new DebitCardCheckout();
 }
@Bean
public Checkout   chk2() {
   return new CreditCardCheckout();
 }
@Bean
public Checkout   chk3() {
   return new NetbankingCheckout();
 }

@Bean
public OrderProcessor   op() {
     OrderProcessor  op = new OrderProcessor();  // consumer creation
       op.setSender(ns1) ;  // inject ns1  , WhatsAppNotificationSender  into op
       op.setCheckout(chk1)  ;  //  inject chk1, DebitCardCheckout  into op
      return op;
 }

}


The container reads the configuration file XML file OR Java Bean Config file and loads all of them into memory


Spring framework Modules
**********************
A module provides certain functionality to an application.  For e.g. JDBC, ORM, JMS	
Core Module,  Context module

The core module / context provides the DEPENDENCY INJECTION functionality with the help of the interfaces and their implementation classes.

The BeanFactory interface (org.springframework.beans.factory)
Objects of the implementation classes of this interface plays the role of "container"

The ApplicationContext interface
This is the child interface of the BeanFactory, and is currently in use.

A couple of implementation class names of ApplicationContext are
(i) ClassPathXmlApplicationContext
(ii) AnnotatioConfigApplicationContext


Steps involved in working with a spring enabled project
*********************************************
1. Create a project and choose/add the required dependencies
2. Create all the packages for different layers of the application, e.g.  dvo, service, dao, controller, exception
3. Develop all the code as needed in the respective files
4. Declare the bean configuration using any possible approach of your wish
5. Develop the main class with a main method inside that.
6.Inside the  main method, create a container object that points to either the XML file OR the  Bean config .class file
7.  Ask the container object for the required beans and then call the methods  on it.

Types of dependency Injection
***********************
1. setter injection :  In this model the spring container makes a call to the set*() method on the dependency consumer
2. constructor injection: In this model, the spring container executes the constructor() to pass the dependencies into the consumer
3. interface injection



Which interface(s) and objects of implementation classes of those interfaces play the role of a spring container ?
ApplicationContext (BeanFactory)


Auto wiring
*********
it is the process using which the spring container (ApplicationContext) injects the dependencies into the consumers automatically when we make use of @Autowired annotation  on top of 
1. dependency  object name within the source of the dependency consumer .java file
2. set*() method of the dependency within the source of the dependency consumer .java file
3 constructor() of within the source of the dependency consumer .java file

@Qualifier 
********
It is used in combination with @Autowired incase of more than one matching dependencies.

Database Access using Spring Framework
*********************************
There are different ways we can access database using spring framework

1. using classic JDBC 
2. using JdbcTemplate class provided by spring DAO module
3. using ORM template class provide by spring ORM module
4. using Spring Data JPA project....

What is Spring Data JPA ?
  It is a one of the projects from spring eco system
  Spring Data JPA is even more advanced than Hibernate JPA ORM and provides a lot of automatic code





23rd  April 2025
==================================================================================
Spring data work flow  under the covers
**********************************
Spring Data JPA  ===> Spring JPA specific ORM module, In this module there is one in built class called "LocalEntityManagerFactoryBean"==> Hibernate JPA,  EntityManagerFactory, EntityManager


In order to work with spring data JPA, we need the following dependencies at the minimum

1. spring-context:  this is required for  ApplicationContext / AnnotationConfigApplicationContext  and related things
2. spring-data-jpa
3. spring orm
4. hibernate core
5. MySQL connector


TransactionManager(I)  a few classes are JpaTransactionManager, HibernateTransactionManager, 
*****************
It is an object that automatically takes care of  begin/commit/rollback of the transaction as needed.



How does spring data jpa know for which repository interfaces it has to generate implementation classes without spring boot





Collect all your work from day 1 up to and including yesterday, into one folder with following naming format

empcode-firstname-lastname

zip, it and upload

Repeat the DATA JPA EXAMPLE for anything like such as
 Employee.java
 ************
empid, empname, doj, salary

OR
Movie
*****
movieid, moviename, 
Client computer
************
A computer that requests data from some other computer (server computer) 

Server Computer
***************
A computer that sends responses to a client computer.  Server computer sends data or error to the client computer

Web client
********
It is a software that a client computer uses to send requests to server computer   e.g. browser software like chrome, safari

Web server
*********
It is  a software that a server computer uses to send responses to a client computer   e.g.  tomcat, nginx, iis

Web application
*************
It is a collection of a different files like HTML, CSS, JavaScript, Java .class files, xml files, images, audio/video files.
Web application lives on server computer

HTTP
*****

What is HTTP ?
  It is a language that is used for transferring data/documents between the browsers and servers.

HTTP Message
************
**************
HTTP messages are the mechanism used to exchange data between a server and a client in the HTTP protocol. 
There are two types of messages: 
HTTP requests message
HTTP response message

HTTP request message :  
******************** 
It is a message that a browser sends to the server.

 A browser can a send message
  (i) asking to get some information (document/object)
  (ii) asking to store some information on the server 
  (iii) asking to delete some information on the server 
  (iv) asking to modify some information on the server

HTTP response message: 
*********************
 It is a  message that a server sends in response to the browser's request. 
 A server can send message to client
 (i) with the data that is asked for
 (ii) OR an error indicating some kind of problem

HTTP method
************
It represents an action that a client wants to execute on the web server.  HTTP protocol defines various methods but the most commonly used ones are
GET, POST, PUT , DELETE
GET: Retrieves data from a specified resource.
POST: Submits data to be processed to a specified resource, often creating a new resource.
PUT: Replaces an entire resource with new data.
PATCH: Partially updates a resource.
DELETE: Deletes a specified resource. 

HTTP Status code
***************
HTTP status codes are three-digit codes that indicate the outcome of a request made by a web browser or client to a web server.

These codes are useful for understanding the status of web requests and can help diagnose and resolve issues. 

They are grouped into five classes, each indicating a different type of response: 
(i) informational
(ii) successful
(iii) redirection
(iv) client error
(v) server error

HTTP message parts
*****************
1. start line  
2. headers
3. empty line
4. message body


MVC
***
Servlets
Spring MVC


spring MVC
**********
What is spring MVC?
 It is one of the modules in spring framework. This MVC framework contains a few bunch of in built classes, interfaces, annotations etc

Spring MVC simplifies web development by providing a framework for managing these components and handling HTTP requests and responses

The following are the main elements (classes/interfaces) in spring MVC


Guest-->FrontDesk--Waiter-->Chef-->Server-->Guest

Browser --->DispatcherServlet-->HandlerMapping-->HandlerAdapter-->Controller-->ViewResolver-->View-->Browser
                  (front controller servlet)                       (servlet)





@Controller
@RequestMapping("/product")
public class  ProductController {

@RequestMapping("/add")
public void addRecord() {

}

@RequestMapping("/delete")
public void deleteRecord() {

}
}


As a spring MVC developer, we need to do the follwoing work to develop MVC application

1.  Register the DispatcherServlet  with the application.
    Registering means, declare the name of DispatcherServlet and making it available to be loaded into memory
2.  We need to declare HandlerMapping as a bean    (this is automatic)
3. We need to develop the code for  controller classes

@Controller  
@RequestMapping("/product")
public class  ProductController {

@RequestMapping("/add")
public void addRecord() {

}

@RequestMapping("/delete")
public void deleteRecord() {

}
}

24th  April 2025
=======================================================================================

Web service (what, why, types)

A web service is a software program that provides some functionality, that can be accessed over the web

Webservices help in application to application communication and exchange data OR some functionality

API:
Application Programming Interface


If application A wants to provide it's functionality to application B, then it does so by the concept of API.

Application B - develops one program, to that program application B maps one URL

Greeting --- /greeting

Now if application A wants to make use of the greeting functionality provided by application B, then application A needs to make a call to /greeting     http://www.applicationb.com/apis/greeting

http://www.applicationb.com/apis/greeting
http://www.applicationb.com/apis/backgroundverification
http://www.applicationb.com/apis/payroll
http://www.applicationb.com/apis/recruitment

REST
*****
REST: REpresentational State Transfer

What is REST?
It is a set of guidelines for building networked applications.

What is the full form of API ?
Application Programming Interface

What is REST api ?
It is a  program that is provides (exposes/produces) data which is used (consumed) by other applications(consuming application)

REST api producer ?
A individual/team/company who develops the REST api (the program that produces data)

RESTful resource : It is the data/information that is exposed by the REST api producer

REST api URL : Every piece of data/information that is exposed by the REST api producer is identified by a URL to consume it

REST api consumer?
An individual/team/company who develops the program/application that consumes the REST api

RESTful webservice : It is a logical grouping (or logical collection) of different REST api

REST api programming library : 
It is  a set of predefined classes, interfaces, annotations which are used to develop REST api and also to consume the REST api

JAX-RS :Java api for XML based RESTFUL services

What is JAX-RS ?
It is a specification ( a document) that describes, about, "how" the classes/interfaces/annotations should provide the functionality for developing REST api and consuming them

JAX-RS library provider : An individual or company/team who develops the classes/interfaces/annotations according to the rules described in the JAX-RS specification

JAX-RS implementations
(i) Jersey  : provided by Oracle
(ii) RESTEasy : provided by JBOSS community (JBOSS - : Java Beans Open Source Software)

RESTcontroller : An MVC controller (a program) that produces the REST api 

Spring REST :  It is  set of annotations/classes/interfaces used to develop 
 (i) programs that produce REST api
 (ii)programs that consume REST api

Spring MVC and REST annotations
 @Controller
 @RestController
 @RequestMapping
 @PathVariable
 @RequestBody
 @ResponseBody
 @GetMapping
 @PostMapping
 @PutMapping
 @DeleteMapping

To develop the spring boot application, we need to make create the Maven/Gradle project.

Spring REST api application 
 src/main/resources  application.properties  :    
  This file is used to declare various properties and their values.   there are  so many properties related different categories of the project
  If we make use of Spring Data JPA, we need to type the JDBC properties like url, username,  in this file
  If we make use of microservices related  programming (patterns) we need to declare properties as relevant
  If we use MVC, then we need to declare mvc related properties

In addition to the in built properties, we can declare our own properties also in that file

propertyname.subname.subname.subname.subname = value
propertyname.subname.subname.subname.subname = value


The application.yml, is also used to configure the properties but with the hierarchical property syntax

http://localhost:8080



POSTMAN
Node JS
MongoDB
Git
MySQL 
VS code


25th  April 2025
========================================================================
Microservices

Service discovery pattern:     
We need to develop the following
1. One spring boot project, which when launched, acts as  service discovery server
2. One or more microservices as needed (e.g.product rest api)  , which when launched, register their details with the discovery server
3. one or more consuming applications, that consume the REST api of step-2. To consume the REST api of step-2, consuming applications, talk to discovery server, discovery then discovers the port number, ip address of the target microservice that the consuming application wants to talk to.





What is spring boot ?
  It is a tool for developing microservices ( in more clear way, It is a software that provides the facilities that are needed to develop a microservice architecture based applications)

The main purpose of spring boot is to develop microservice based applications, however, we can also use it to develop monolithic applications

spring boot features
******************
1. auto configuration :   using this feature, spring boot automatically  creates and registers the beans like LocalEntityManagerFactoryBean, JpaTransactionManager, DispatcherServlet, HandlerAdapter and much more, by looking at the dependencies
2. actuator (spring boot actuator) :  It is a facility offered by spring boot, using which we can see the different metrics of an application,    how many beans are there, how many urls are there,  is the app healthy or not
3. spring boot also provides the automatic dependency management for the most part.
4. spring boot starters.   it is the way using which spring boot takes care of automatic dependency management.
5.  application.properties/ application.yml 



Service discovery pattern:     
We need to develop the following
1. One spring boot project, which when launched, acts as  service discovery server.  
   To develop this project, we need to make use of some component from spring cloud eureka server,  
   We need to choose eureka server while creating the application, and we have to annotate the spring boot main class with the @EnableEurekaServer  and then declare a few properties to it.

server.port=8761
eureka.client.register-with-eureka=false
eureka.client.fetch-registry = false

What is Eureka Server ? 
 It is the name of the discovery server software that is available from a dependency called spring cloud starter Netflix eureka server.    Discovery server is a software that hosts the microservices details such as port number, name, ip details...

2. One or more microservices as needed (e.g.product rest api)  , which when launched, register their details with the discovery server

3. one or more consuming applications, that consume the REST api of step-2. To consume the REST api of step-2, consuming applications, talk to discovery server, discovery then discovers the port number, ip address of the target microservice that the consuming application wants to talk to.

BankAccount
***********
actActnumber
customerName;
actBalance

+ extra task,   you need to add exception handling facility 

"How to handle exceptions in spring boot"

OR

spring boot global exception handling

bankaccount-rest-api 
bankaccount-consumer   post, put, delete, get































